/// <reference types="node" />
import { Chalk } from 'chalk';
import { MaybeTimeDuration } from 'typed-duration';
import { ZeebeGrpcClient } from '../zb/ZeebeGrpcClient';
import { ConnectionStatusEventMap } from './ConnectionStatusEvent';
import { StatefulLogInterceptor } from './StatefulLogInterceptor';
import { TypedEmitter } from './TypedEmitter';
import * as ZB from './interfaces-1.0';
import { ZBClientOptions } from './interfaces-published-contract';
export interface ZBWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> {
    grpcClient: ZB.ZBGrpc;
    id: string | null;
    taskType: string;
    options: ZB.ZBWorkerOptions<WorkerInputVariables> & ZBClientOptions;
    idColor: Chalk;
    zbClient: ZeebeGrpcClient;
    log: StatefulLogInterceptor;
    taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    inputVariableDto?: {
        new (...args: any[]): Readonly<WorkerInputVariables>;
    };
    customHeadersDto?: {
        new (...args: any[]): Readonly<CustomHeaderShape>;
    };
    tenantIds: string[] | [string] | undefined;
}
export declare class ZBWorkerBase<WorkerInputVariables = any, CustomHeaderShape = any, WorkerOutputVariables = any> extends TypedEmitter<ConnectionStatusEventMap> {
    private static readonly DEFAULT_JOB_ACTIVATION_TIMEOUT;
    private static readonly DEFAULT_MAX_ACTIVE_JOBS;
    activeJobs: number;
    grpcClient: ZB.ZBGrpc;
    maxJobsToActivate: number;
    taskType: string;
    timeout: MaybeTimeDuration;
    pollCount: number;
    protected zbClient: ZeebeGrpcClient;
    protected logger: StatefulLogInterceptor;
    protected taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    protected cancelWorkflowOnException: boolean;
    private closeCallback?;
    private closePromise?;
    private closing;
    private closed;
    private id;
    private longPoll;
    private debugMode;
    private capacityEmitter;
    private stalled;
    private connected;
    private readied;
    private jobStream?;
    private activeJobsThresholdForReactivation;
    private pollInterval;
    private pollLoop;
    private pollMutex;
    private backPressureRetryCount;
    private fetchVariable;
    private inputVariableDto;
    private customHeadersDto;
    private tenantIds;
    private CAMUNDA_JOB_WORKER_MAX_BACKOFF_MS;
    backoffTimeout: NodeJS.Timeout | undefined;
    constructor({ grpcClient, id, log, options, taskHandler, taskType, zbClient, inputVariableDto, customHeadersDto, tenantIds, }: ZBWorkerConstructorConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>);
    /**
     * Returns a promise that the worker has stopped accepting tasks and
     * has drained all current active tasks. Will reject if you try to call it more than once.
     */
    close(timeout?: number): Promise<null>;
    log(msg: ZB.JSON): void;
    debug(msg: ZB.JSON): void;
    error(msg: ZB.JSON): void;
    protected drainOne(): void;
    protected handleJobs(jobs: ZB.Job<WorkerInputVariables, CustomHeaderShape>[]): void;
    protected makeCompleteHandlers<T>(thisJob: ZB.Job<WorkerInputVariables, CustomHeaderShape>): ZB.JobCompletionInterface<T> & ZB.JobCompletionInterface<T>;
    private failJob;
    private completeJob;
    private errorJob;
    private handleStreamEnd;
    private poll;
    private activateJobs;
    private handleJobResponse;
}
