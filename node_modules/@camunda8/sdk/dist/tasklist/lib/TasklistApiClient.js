"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TasklistApiClient = void 0;
const debug_1 = require("debug");
const got_1 = __importDefault(require("got"));
const lib_1 = require("../../lib");
const TasklistDto_1 = require("./TasklistDto");
const utils_1 = require("./utils");
const trace = (0, debug_1.debug)('camunda:tasklist');
const TASKLIST_API_VERSION = 'v1';
/**
 * The high-level client for the Tasklist REST API
 * @example
 * ```
 *
 * ```
 */
class TasklistApiClient {
    /**
     * Tasklist API Client.
     * All constructor parameters for configuration are optional. If no configuration is provided, the SDK will use environment variables to configure itself.
     * See {@link CamundaSDKConfiguration} for the complete list of configuration parameters. Values can be passed in explicitly in code, or set via environment variables (recommended: separate configuration and application logic).
     * Explicitly set values will override environment variables, which are merged into the configuration.
     * @example
     * ```
     * const tasklist = new TasklistApiClient()
     * const tasks = await tasklist.getTasks({ state: TaskState.CREATED })
     * ```
     *
     */
    constructor(options) {
        const config = lib_1.CamundaEnvironmentConfigurator.mergeConfigWithEnvironment(options?.config ?? {});
        this.oAuthProvider =
            options?.oAuthProvider ?? (0, lib_1.constructOAuthProvider)(config);
        this.userAgentString = (0, lib_1.createUserAgentString)(config);
        const baseUrl = (0, lib_1.RequireConfiguration)(config.CAMUNDA_TASKLIST_BASE_URL, 'CAMUNDA_TASKLIST_BASE_URL');
        const prefixUrl = `${baseUrl}/${TASKLIST_API_VERSION}`;
        this.rest = (0, lib_1.GetCustomCertificateBuffer)(config).then((certificateAuthority) => got_1.default.extend({
            prefixUrl,
            retry: lib_1.GotRetryConfig,
            https: {
                certificateAuthority,
            },
            handlers: [lib_1.beforeCallHook],
            hooks: {
                beforeRetry: [
                    (0, lib_1.makeBeforeRetryHandlerFor401TokenRetry)(this.getHeaders.bind(this)),
                ],
                beforeError: [(0, lib_1.gotBeforeErrorHook)(config)],
                beforeRequest: config.middleware ?? [],
            },
        }));
        trace(`prefixUrl: ${prefixUrl}`);
    }
    async getHeaders() {
        const authorization = await this.oAuthProvider.getHeaders('TASKLIST');
        return {
            'content-type': 'application/json',
            ...authorization,
            'user-agent': this.userAgentString,
            accept: '*/*',
        };
    }
    replaceDatesWithString(query) {
        if (query.followUpDate) {
            if (typeof query.followUpDate.from === 'object') {
                query.followUpDate.from = query.followUpDate.from.toISOString();
            }
            if (typeof query.followUpDate.to === 'object') {
                query.followUpDate.to = query.followUpDate.to.toISOString();
            }
        }
        if (query.dueDate) {
            if (typeof query.dueDate.from === 'object') {
                query.dueDate.from = query.dueDate.from.toISOString();
            }
            if (typeof query.dueDate.to === 'object') {
                query.dueDate.to = query.dueDate.to.toISOString();
            }
        }
        return query;
    }
    /**
     * Query Tasklist for a list of tasks. See the [API documentation](https://docs.camunda.io/docs/apis-clients/tasklist-api/queries/tasks/).
     * @throws Status 400 - An error is returned when more than one search parameters among [`searchAfter`, `searchAfterOrEqual`, `searchBefore`, `searchBeforeOrEqual`] are present in request
     * @throws {RESTError}
     * @example
     * ```
     * const tasklist = new TasklistApiClient()
     *
     * async function getTasks() {
     *   const res = await tasklist.searchTasks({
     *     state: TaskState.CREATED
     *   })
     *   console.log(res ? 'Nothing' : JSON.stringify(res, null, 2))
     *   return res
     * }
     * ```
     * @param query
     */
    async searchTasks(query) {
        const headers = await this.getHeaders();
        const url = 'tasks/search';
        trace(`Requesting ${url}`);
        const rest = await this.rest;
        return rest
            .post(url, {
            json: this.replaceDatesWithString(query),
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, TasklistDto_1.TaskSearchResponse),
        })
            .json();
    }
    /**
     * Return a task by id, or throw if not found.
     * @throws {RESTError} Will throw if no task of the given taskId exists
     * @returns
     */
    async getTask(taskId) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .get(`tasks/${taskId}`, {
            headers,
        })
            .json();
    }
    /**
     * Get the form details by form id and processDefinitionKey.
     * @throws {RESTError}
     */
    async getForm(formId, processDefinitionKey, version) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .get(`forms/${formId}`, {
            searchParams: {
                processDefinitionKey,
                version,
            },
            parseJson: (text) => (0, lib_1.losslessParse)(text, TasklistDto_1.Form),
            headers,
        })
            .json();
    }
    /**
     * This method returns a list of task variables for the specified taskId and variableNames. If the variableNames parameter is empty, all variables associated with the task will be returned.
     * @throws {RESTError}
     */
    async getVariables({ taskId, variableNames, includeVariables, }) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .post(`tasks/${taskId}/variables/search`, {
            body: (0, lib_1.losslessStringify)({
                variableNames: variableNames || [],
                includeVariables: includeVariables || [],
            }),
            headers,
        })
            .json();
    }
    /**
     * https://docs.camunda.io/docs/apis-clients/tasklist-api/queries/variable/
     * @throws Throws 404 if no variable of the id is found
     */
    async getVariable(variableId) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .get(`variables/${variableId}`, {
            headers,
        })
            .json();
    }
    /**
     * Assign a task with taskId to assignee or the active user.
     * @throws {RESTError}
     * @throws Status 400 - An error is returned when the task is not active (not in the CREATED state).
     * Status 400 - An error is returned when task was already assigned, except the case when JWT authentication token used and allowOverrideAssignment = true.
     * Status 403 - An error is returned when user doesn't have the permission to assign another user to this task.
     * Status 404 - An error is returned when the task with the taskId is not found.
     */
    async assignTask({ taskId, allowOverrideAssignment = false, assignee, }) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .patch(`tasks/${taskId}/assign`, {
            body: (0, lib_1.losslessStringify)({
                assignee,
                allowOverrideAssignment,
            }),
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, TasklistDto_1.TaskResponse),
        })
            .json();
    }
    /**
     * Complete a task with taskId and optional variables
     * @throws {RESTError}
     * @throws Status 400 An error is returned when the task is not active (not in the CREATED state).
     * @throws Status 400 An error is returned if the task was not claimed (assigned) before.
     * @throws Status 400 An error is returned if the task is not assigned to the current user.
     * @throws Status 403 User has no permission to access the task (Self-managed only).
     * @throws Status 404 An error is returned when the task with the taskId is not found.
     */
    async completeTask(taskId, variables) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .patch(`tasks/${taskId}/complete`, {
            headers,
            body: (0, lib_1.losslessStringify)({
                variables: (0, utils_1.encodeTaskVariablesForAPIRequest)(variables || {}),
            }),
            parseJson: (text) => (0, lib_1.losslessParse)(text, TasklistDto_1.TaskResponse),
        })
            .json();
    }
    /**
     * Unassign a task with taskId
     * @throws Status 400 An error is returned when the task is not active (not in the CREATED state).
     * @throws Status 400 An error is returned if the task was not claimed (assigned) before.
     * @throws Status 404 An error is returned when the task with the taskId is not found.
     * @throws {RESTError}
     */
    async unassignTask(taskId) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest
            .patch(`tasks/${taskId}/unassign`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, TasklistDto_1.TaskResponse),
        })
            .json();
    }
}
exports.TasklistApiClient = TasklistApiClient;
//# sourceMappingURL=TasklistApiClient.js.map