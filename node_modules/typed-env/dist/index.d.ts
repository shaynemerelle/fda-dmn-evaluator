//#region src/index.d.ts
interface ArgInfoType {
  type: 'number' | 'string' | 'array' | 'boolean';
}
interface ArgInfoParser {
  parser: (input: string) => unknown;
}
interface ArgInfoOptional {
  optional?: boolean;
}
interface ArgInfoDefault {
  default?: unknown;
}
interface ArgInfoChoices {
  choices?: readonly unknown[];
}
type ArgInfo = (ArgInfoType | ArgInfoParser) & ArgInfoOptional & ArgInfoDefault & ArgInfoChoices;
interface MappedArgType<Choice> {
  string: Choice extends (infer U)[] ? U : string;
  number: Choice extends (infer U)[] ? U : number;
  boolean: boolean;
  array: string[];
}
type Mutable<T> = { -readonly [P in keyof T]: T[P] };
type GetArgTypeInner<T extends ArgInfo> = T extends ArgInfoParser ? ReturnType<T['parser']> : T extends ArgInfoType ? MappedArgType<Mutable<T['choices']>>[T['type']] : never;
type GetArgTypeOptional<T extends ArgInfo> = T extends ArgInfoDefault ? T['default'] : undefined;
type GetArgType<T extends ArgInfo> = T extends ArgInfoOptional ? GetArgTypeInner<T> | GetArgTypeOptional<T> : GetArgTypeInner<T>;
type ArgReturnType<T extends Record<string, ArgInfo>> = { [K in keyof T]: GetArgType<T[K]> };
interface Options {
  env?: Record<string, string> | NodeJS.ProcessEnv;
}
type Config = Record<string, ArgInfo>;
declare function createEnv<const T extends Config>(info: T, options?: Options): ArgReturnType<T>;

//#endregion
export { Config, Options, createEnv };
//# sourceMappingURL=index.d.ts.map